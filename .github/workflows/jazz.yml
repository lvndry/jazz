name: Jazz AI

on:
  pull_request:
    types: [opened, synchronize]

permissions:
  contents: read
  pull-requests: write

env:
  PR_BASE_SHA: ${{ github.event.pull_request.base.sha }}
  PR_HEAD_SHA: ${{ github.event.pull_request.head.sha }}

jobs:
  code-review:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout PR head
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Install Jazz
        run: npm install -g jazz-ai

      - name: Setup Jazz agent and workflow
        run: |
          mkdir -p .jazz/agents workflows/code-review
          cp .github/jazz/agents/ci-reviewer.json .jazz/agents/
          sed -e "s/__PR_BASE_SHA__/$PR_BASE_SHA/g" -e "s/__PR_HEAD_SHA__/$PR_HEAD_SHA/g" \
            .github/jazz/workflows/code-review/WORKFLOW.md > workflows/code-review/WORKFLOW.md
          echo "--- Substituted workflow ---"
          cat workflows/code-review/WORKFLOW.md

      - name: Run code review
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          CI: "true"
          JAZZ_DISABLE_CATCH_UP: "1"
        run: |
          set -euo pipefail
          jazz --output raw workflow run code-review --auto-approve --agent ci-reviewer \
            | tee /tmp/jazz-review.txt

      - name: Post review comments
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const output = fs.readFileSync('/tmp/jazz-review.txt', 'utf8');

            // Read model from agent config for display in review comment
            let modelLabel = '';
            try {
              const agent = JSON.parse(fs.readFileSync('.github/jazz/agents/ci-reviewer.json', 'utf8'));
              if (agent.model) modelLabel = `\n\n*Model: ${agent.model}*`;
            } catch (_) {}

            // Parse JSON from agent output (quad backticks first, then triple)
            let jsonBlocks = [...output.matchAll(/````json\s*\n([\s\S]*?)````/g)];
            if (jsonBlocks.length === 0) {
              jsonBlocks = [...output.matchAll(/```json\s*\n([\s\S]*?)```/g)];
            }

            let comments = [];
            try {
              if (jsonBlocks.length > 0) {
                comments = JSON.parse(jsonBlocks[jsonBlocks.length - 1][1].trim());
              }
            } catch (e) {
              console.log('Failed to parse JSON:', e.message);
            }

            if (!Array.isArray(comments) || comments.length === 0) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: comments.length === 0
                  ? `## Jazz Code Review\n\nNo issues found.${modelLabel}`
                  : `## Jazz Code Review\n\n${output.slice(-60000) || '_No output from review._'}`
              });
              return;
            }

            // Filter to valid inline comments (path must be a real file, line must be positive)
            const validComments = comments.filter(c =>
              c.path && c.line > 0 && !c.path.startsWith('/') && c.path !== 'NO_DIFF'
            );

            // Any comments that couldn't be posted inline become part of the review body
            const invalidComments = comments.filter(c => !validComments.includes(c));
            let reviewBody = `## Jazz Code Review\n\nFound ${comments.length} comment(s).${modelLabel}`;
            if (invalidComments.length > 0) {
              reviewBody += '\n\n### General Comments\n\n';
              reviewBody += invalidComments.map(c => `- ${c.body}`).join('\n');
            }

            if (validComments.length > 0) {
              // Fetch PR files to determine which are deleted (must use LEFT side for those)
              const { data: prFiles } = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number
              });
              const deletedPaths = new Set(
                prFiles.filter((f) => f.status === 'removed').map((f) => f.filename)
              );

              const mapComment = (c) => {
                const isDeleted = deletedPaths.has(c.path);
                const side = isDeleted ? 'LEFT' : (c.side || 'RIGHT');
                const hasValidRange =
                  Number.isInteger(c.start_line) &&
                  Number.isInteger(c.line) &&
                  c.start_line > 0 &&
                  c.start_line < c.line;
                return {
                  path: c.path,
                  line: c.line,
                  ...(hasValidRange && {
                    start_line: c.start_line,
                    start_side: side
                  }),
                  side,
                  body: c.body
                };
              };

              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.payload.pull_request.number,
                commit_id: context.payload.pull_request.head.sha,
                event: 'COMMENT',
                body: reviewBody,
                comments: validComments.map(mapComment)
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: reviewBody
              });
            }
